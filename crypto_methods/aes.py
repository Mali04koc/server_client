"""
Basit AES-128 (ECB) implementasyonu - harici kütüphane yok.
Metin/anahtar UTF-8 alınır, PKCS7 ile pad edilir, çıktı Base64 döner.
ECB yalnızca demo içindir; gerçek güvenlik için IV ve CBC/GCM gerekir.
"""
import base64
from typing import List

Nb = 4  # blok sütunu (her zaman 4)
Nk = 4  # 4 word = 16 byte key (AES-128)
Nr = 10 # tur sayısı

# S-box ve Ters S-box tablosu
S_BOX = [
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]

INV_S_BOX = [
0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d]

RCON = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36]

def _xtime(a: int) -> int:
    return ((a << 1) ^ 0x1B) & 0xFF if (a & 0x80) else (a << 1) & 0xFF

def _gmul(a: int, b: int) -> int:
    p = 0
    for _ in range(8):
        if b & 1:
            p ^= a
        hi = a & 0x80
        a = (a << 1) & 0xFF
        if hi:
            a ^= 0x1B
        b >>= 1
    return p

def _sub_bytes(state: List[int]) -> None:
    for i in range(16):
        state[i] = S_BOX[state[i]]

def _inv_sub_bytes(state: List[int]) -> None:
    for i in range(16):
        state[i] = INV_S_BOX[state[i]]

def _shift_rows(state: List[int]) -> None:
    state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]
    state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]
    state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]

def _inv_shift_rows(state: List[int]) -> None:
    state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]
    state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]
    state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]

def _mix_columns(state: List[int]) -> None:
    for c in range(4):
        i = 4*c
        a0,a1,a2,a3 = state[i:i+4]
        state[i]   = _gmul(a0,2) ^ _gmul(a1,3) ^ a2 ^ a3
        state[i+1] = a0 ^ _gmul(a1,2) ^ _gmul(a2,3) ^ a3
        state[i+2] = a0 ^ a1 ^ _gmul(a2,2) ^ _gmul(a3,3)
        state[i+3] = _gmul(a0,3) ^ a1 ^ a2 ^ _gmul(a3,2)

def _inv_mix_columns(state: List[int]) -> None:
    for c in range(4):
        i = 4*c
        a0,a1,a2,a3 = state[i:i+4]
        state[i]   = _gmul(a0,14) ^ _gmul(a1,11) ^ _gmul(a2,13) ^ _gmul(a3,9)
        state[i+1] = _gmul(a0,9)  ^ _gmul(a1,14) ^ _gmul(a2,11) ^ _gmul(a3,13)
        state[i+2] = _gmul(a0,13) ^ _gmul(a1,9)  ^ _gmul(a2,14) ^ _gmul(a3,11)
        state[i+3] = _gmul(a0,11) ^ _gmul(a1,13) ^ _gmul(a2,9)  ^ _gmul(a3,14)

def _add_round_key(state: List[int], round_key: List[int]) -> None:
    for i in range(16):
        state[i] ^= round_key[i]

def _key_expansion(key_bytes: bytes) -> List[List[int]]:
    """AES-128 key schedule -> 11 round keys"""
    if len(key_bytes) != 16:
        raise ValueError("AES key 16 byte (128-bit) olmalı")
    w = [0]*44
    for i in range(Nk):
        w[i] = (key_bytes[4*i] << 24) | (key_bytes[4*i+1] << 16) | (key_bytes[4*i+2] << 8) | key_bytes[4*i+3]
    for i in range(Nk, Nb*(Nr+1)):
        temp = w[i-1]
        if i % Nk == 0:
            temp = _sub_word(_rot_word(temp)) ^ (RCON[(i//Nk)-1] << 24)
        w[i] = w[i-Nk] ^ temp
    round_keys = []
    for r in range(Nr+1):
        rk = []
        for c in range(4):
            word = w[r*4 + c]
            rk.extend([
                (word >> 24) & 0xFF,
                (word >> 16) & 0xFF,
                (word >> 8) & 0xFF,
                word & 0xFF
            ])
        round_keys.append(rk)
    return round_keys

def _rot_word(word: int) -> int:
    return ((word << 8) & 0xFFFFFFFF) | ((word >> 24) & 0xFF)

def _sub_word(word: int) -> int:
    return ((S_BOX[(word >> 24) & 0xFF] << 24) |
            (S_BOX[(word >> 16) & 0xFF] << 16) |
            (S_BOX[(word >> 8) & 0xFF] << 8) |
            S_BOX[word & 0xFF])

def _pkcs7_pad(data: bytes, block_size: int = 16) -> bytes:
    pad_len = block_size - (len(data) % block_size)
    return data + bytes([pad_len])*pad_len

def _pkcs7_unpad(data: bytes, block_size: int = 16) -> bytes:
    if not data or len(data) % block_size != 0:
        raise ValueError("Geçersiz pad verisi")
    pad_len = data[-1]
    if pad_len == 0 or pad_len > block_size:
        raise ValueError("Geçersiz pad uzunluğu")
    if data[-pad_len:] != bytes([pad_len])*pad_len:
        raise ValueError("Pad doğrulaması başarısız")
    return data[:-pad_len]

def _cipher_block(block: bytes, round_keys: List[List[int]]) -> bytes:
    state = list(block)
    _add_round_key(state, round_keys[0])
    for rnd in range(1, Nr):
        _sub_bytes(state)
        _shift_rows(state)
        _mix_columns(state)
        _add_round_key(state, round_keys[rnd])
    _sub_bytes(state)
    _shift_rows(state)
    _add_round_key(state, round_keys[Nr])
    return bytes(state)

def _inv_cipher_block(block: bytes, round_keys: List[List[int]]) -> bytes:
    state = list(block)
    _add_round_key(state, round_keys[Nr])
    for rnd in range(Nr-1, 0, -1):
        _inv_shift_rows(state)
        _inv_sub_bytes(state)
        _add_round_key(state, round_keys[rnd])
        _inv_mix_columns(state)
    _inv_shift_rows(state)
    _inv_sub_bytes(state)
    _add_round_key(state, round_keys[0])
    return bytes(state)

def aes_encrypt(plaintext: str, key: str) -> str:
    """AES-128 ECB, PKCS7, çıktı Base64 (str)"""
    key_bytes = key.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("AES anahtarı 16 byte (128-bit) olmalı. (örn: 16 karakter)")
    round_keys = _key_expansion(key_bytes)
    data = _pkcs7_pad(plaintext.encode("utf-8"), 16)
    out = b""
    for i in range(0, len(data), 16):
        out += _cipher_block(data[i:i+16], round_keys)
    return base64.b64encode(out).decode("utf-8")

def aes_decrypt(cipher_b64: str, key: str) -> str:
    """AES-128 ECB, PKCS7, giriş Base64 (str)"""
    key_bytes = key.encode("utf-8")
    if len(key_bytes) != 16:
        raise ValueError("AES anahtarı 16 byte (128-bit) olmalı. (örn: 16 karakter)")
    try:
        data = base64.b64decode(cipher_b64.encode("utf-8"))
    except Exception:
        raise ValueError("Geçersiz Base64 şifreli metin")
    if len(data) % 16 != 0:
        raise ValueError("Şifreli metin blok uzunluğunda değil")
    round_keys = _key_expansion(key_bytes)
    out = b""
    for i in range(0, len(data), 16):
        out += _inv_cipher_block(data[i:i+16], round_keys)
    out = _pkcs7_unpad(out, 16)
    return out.decode("utf-8")


